/*
A parametric Christmas tree / tea light generator.

User can set the number of branches per layer and
a smoothness factor along with a base diameter. The
model is intended to print as a 'spiral vase' with
0 layers on the bottom to slip the tea light into.
 
Adjust the number of branches and their 'spikiness'
to taste and adjust the base diameter to match your tea
lights (LED of course!). Mine measures at about 38-mm
but needed a little slop to account for spiral vase
calculations and nozzle spooge. I suggest you print 
1-mm oversize and adjust with some masking tape for
a snug fit.

The mathematical bits are based on Marius Kintel's
list comprehension demos, specifically the 3rd body
body generated by the superformula.scad script here:
https://github.com/openscad/list-comprehension-demos

Enjoy! 
Bob M, December, 2017
*/

// Branch Count
branches = 5; // [3:1:21]

// Branch Smoothness
smoothness = 3; // [2:.5:10]

// Base Diameter (mm)
base = 39; // [35:1:50]

/* [Hidden] */
$fn=48;
angle_step = 2;

//   a  b  m  n1 n2 n3 f
p = [1, 1, branches, smoothness, 4, 4, 8];

layer_a = rands(0, 360/5, 5, seed=41);
layer_a = [0, 90/branches, 180/branches, 270/branches, 0];
layer_s = [3.5, 2.8, 1.75,.9];
layer_h = [0, 20, 42, 58];

// helper function
function r1(phi) = pow(abs(cos(p[2] * phi / 4) / p[0]), p[4]);
function r2(phi) = pow(abs(sin(p[2] * phi / 4) / p[1]), p[5]);

// main superformula returning the radius for a given angle phi
function r(phi, idx) = p[6] * pow(abs(r1(phi) + r2(phi)), -1 / p[3]);

// convert polar coordinates to cartesian coordinates
function point(phi) = [ r(phi) * cos(phi), r(phi) * sin(phi)];

// function to collect all points in 360 degrees
function points(angle) = [for (i=[0:angle_step:360-angle_step]) point(i)];

module layer(s, a) {
    
    rotate([0,0, a]) scale(s) translate([0,0,4]) {
        linear_extrude(height = 8, scale = 0)
            polygon(points(0));

        rotate([180,0,0]) linear_extrude(height = 4, scale = .5)
            polygon(points(0));
    }
}


//base
translate([0,0,-16]) cylinder(r=base/2, h=16);
cylinder(r1=base/2, r2 = base/4, h = 8);

// 4 layers
for (i=[0:3]) {
    translate([0,0,layer_h[i]]) layer(layer_s[i], layer_a[i]);
}